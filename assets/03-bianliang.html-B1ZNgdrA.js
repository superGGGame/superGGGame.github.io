import{_ as s,c as a,a as e,o as t}from"./app-DEZf6KcN.js";const p={};function l(o,n){return t(),a("div",null,n[0]||(n[0]=[e(`<h1 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h1><p>大多数情况下，JavaScript 应用需要处理信息。变量就是用来储存这些信息的。</p><h2 id="变量-1" tabindex="-1"><a class="header-anchor" href="#变量-1"><span>变量</span></a></h2><p>变量是数据的“命名存储”。 代表一个有名字的、具有特定属性的存储单元，用于存放数据。变量来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念。</p><h2 id="变量命名和保留字" tabindex="-1"><a class="header-anchor" href="#变量命名和保留字"><span>变量命名和保留字</span></a></h2><p>JavaScript 的变量命名有两个限制:</p><ol><li>变量名称必须仅包含字母 、数字 、 符号 <code>$</code> 和 <code>_</code></li><li>首字符必须为非数字</li></ol><blockquote><p><strong>为什么变量命名限制中没有提到可以使用诸如中文等语言进行命名，但是实际使用中文命名并不会报错？</strong></p><p>在 JavaScript 中，变量命名规则基于 ECMAScript 规范，，但是在 ECMAScript 规范中，允许使用包括中文在内的 Unicode 字符作为标识符（变量名、函数名等）。在技术上来说，使用诸如中文这类语言进行变量命名是可行的。 英文命名仍是主流，在实际开发中，考虑到协作性和国际化标准，任默认使用英文进行变量命名。在特定场景中可以酌情使用中文命名（如教学），如果决定在项目中使用中文，建议在项目中明确规范，并确保团队达成共识。</p></blockquote><p><em>tip</em> ：JavaScript 是区分大小写的</p><h2 id="三种变量简介" tabindex="-1"><a class="header-anchor" href="#三种变量简介"><span>三种变量简介</span></a></h2><p>在JavaScript中，变量声明主要有 <code>var</code>、 <code>let</code> 和 <code>const</code> 三种方式。</p><ul><li><code>var</code>：老旧的变量声明方式，全局变量<br> 最古老的变量声明方式，多用于老旧代码维护，现代JS少用甚至于不再使用。</li><li><code>let</code>：局部变量 ES6 （ECMAScript 2015）新增的变量声明方式，比较现代，推荐使用。</li><li><code>const</code>：常量 ES6 （ECMAScript 2015）新增的变量声明方式，只允许初始化时赋值，作为常量使用。</li></ul><h2 id="变量四个基本阶段" tabindex="-1"><a class="header-anchor" href="#变量四个基本阶段"><span>变量四个基本阶段</span></a></h2><ol><li>变量声明 变量声明指的是使用关键字来创建一个变量，像下面这样做：<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> message<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">,</span></span>
<span class="line">  message <span class="token operator">=</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>初始化（变量初始化） 变量的初始化指的是变量在声明时赋予初始值的过程。代码执行到声明语句时完成。例如：<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>这样就完成了初始化。此外还有一些初始化注意点我们会在稍后讨论。</li><li>赋值（变量赋值） 简单来说，变量赋值是指对已经进行了声明并初始化的变量进行修改的操作。例如：<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//这里对a变量进行了赋值。</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>释放（变量释放） 变量释放较为复杂，在JS中变量内存释放由 <strong>GC（Garbage Collection，垃圾回收机制）</strong> 自动管理。我们这里给出一种辅助GC进行内存释放的方法，但是在实际中由于GC的存在并不需要这样操作，这里为了完整性也给出介绍。<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//此时a变量被指向null，会在后续被GC进行回收。</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>在后续我们会对GC进行较为详细介绍。</li></ol><p>上面就是JS中变量的四个所处阶段（我个人理解），下面我们来讨论一些细节点。</p><blockquote><p><strong>关于重复声明问题</strong><code>var</code> 由于其出现在JS构建初期，没有考虑到重复声明的问题，其允许重复声明，而 <code>let</code> 和 <code>const</code> 出现于 ES6 （ECMAScript 2015），考虑到了重复声明问题，不允许重复声明相同变量名。 其次需要注意，在不同的变量作用域中是可以进行重复声明的，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> a11 <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a11<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错，因为变量被提升了，产生TDZ（暂时性死区）</span></span>
<span class="line"> 	<span class="token keyword">let</span> a11 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a11<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，同样名称的变量在不同作用域中是可以同时存在的，由于不在同一个作用域，因此并不违反不可重复声明的原则。</p></blockquote><blockquote><p><strong>变量初始化和变量赋值的区别</strong> 首先，变量初始化是发生在变量声明的同时。由于历史原因，对于var来说，其在变量提升的时候会直接初始化，值为 <code>undefined</code> 。对于let和const来说，如果直接在声明时显式赋值则将赋予的值作为初始化值。但是如果不在声明时显式赋值，对于 <code>let</code> 来说，会默认初始化得到 <code>undefined</code> 值；而对于 <code>const</code> 来说，则会直接报错， <code>cosnt</code> 需要立即初始化。 同时需要注意，由于 TDZ（Temporal Dead Zone，暂时性死区） 存在，<code>let</code> 和 <code>const</code> 不会在执行到声明代码前被访问到。</p></blockquote><h2 id="预解析、变量提升和tdz-暂时性死区" tabindex="-1"><a class="header-anchor" href="#预解析、变量提升和tdz-暂时性死区"><span>预解析、变量提升和TDZ（暂时性死区）</span></a></h2><ul><li><p><strong>预解析</strong> 预解析是在程序执行之前，会进行一遍预检。搜索当前作用域所有 <code>function</code> 和变量。并且每次更换作用域都会在当前作用域进行一次预解析（变量提升也是如此）。</p></li><li><p><strong>变量提升的本质</strong> 无论是 <code>var</code> 、 <code>let</code> 还是 <code>const</code> ， 所有变量声明都会在代码执行前的<strong>编译阶段</strong>被提升到作用域的顶部。区别在于初始化和访问规则不同。 <code>function</code> 也会被提升到最前面，但是初始化的值为函数本身。</p></li><li><p><strong>TDZ（Temporal Dead Zone，暂时性死区）</strong> 是 JavaScript 与 <code>let</code> 和 <code>const</code> 声明相关的一个概念。它描述了变量在声明之前无法被访问或操作的区域。 TDZ的范围就是从代码块的开始到变量声明语句执行之前的区域，如果访问这个变量，会触发 <code>ReferenceError</code> ，因为变量已经存在（声明被提升），但尚未初始化。</p></li></ul><h2 id="变量内存空间的分配" tabindex="-1"><a class="header-anchor" href="#变量内存空间的分配"><span>变量内存空间的分配</span></a></h2><p>在JavaScript中，不同类型的变量分配内存的时机是不一样的。</p><ul><li><code>var</code>：内存分配和初始化（<code>undefined</code>）在变量提升阶段完成。</li><li><code>let</code> 和 <code>const</code>：内存分配在进入作用域时完成（它们是块级作用域），而初始化在执行到声明语句时完成。</li><li>内存分配与初始化时分离的，但内存分配一定发生在初始化之前。</li></ul><h2 id="变量作用域" tabindex="-1"><a class="header-anchor" href="#变量作用域"><span>变量作用域</span></a></h2><h3 id="作用域类型" tabindex="-1"><a class="header-anchor" href="#作用域类型"><span>作用域类型</span></a></h3><ol><li><p>全局作用域 （Global Scope）</p><ul><li>定义：在函数或代码块外声明的变量，或直接绑定到 <code>window</code> (浏览器环境) 的变量。</li><li>生命周期：页面关闭时释放。</li><li>特点： <ul><li>任何地方都可以访问</li><li>滥用会导致命名冲突</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">var</span> globalVar <span class="token operator">=</span> <span class="token string">&#39;全局变量&#39;</span>； <span class="token comment">//全局作用域</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>局部作用域（Local Scope）</p><ul><li>函数作用域（ Function Scope ） <ul><li>定义：在函数内部声明的变量（使用 <code>var</code>）。</li><li>生命周期：函数执行完毕后释放（闭包函数例外）。</li></ul></li><li>块级作用域（ Block Scope ） <ul><li>由 <code>{}</code> 包裹的代码块 （如 <code>if</code>、<code>for</code>），使用<code>let</code> / <code>const</code> 声明的变量。</li><li>生命周期： 代码块执行完毕后释放。</li></ul></li></ul></li></ol><blockquote><p>闭包：内部函数保留对外部函数变量的引用，延长其生命周期。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"> <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">   <span class="token keyword">return</span> <span class="token operator">++</span>count<span class="token punctuation">;</span> <span class="token comment">// 闭包引用外层 count</span></span>
<span class="line"> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1（count 未被释放）</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="作用域链-scope-chain" tabindex="-1"><a class="header-anchor" href="#作用域链-scope-chain"><span>作用域链 （Scope Chain）</span></a></h3><ul><li>定义： <code>作用域链</code>是 JavaScript 查找变量的机制： 从当前作用域逐级向上（外层作用域）查找变量，直到全局作用域。</li><li>本质： 每个函数在创建时都会保存其外部作用域的引用，形成链式结构。</li></ul><p>示例如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> global <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> outerVar <span class="token operator">=</span> <span class="token string">&quot;outer&quot;</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> innerVar <span class="token operator">=</span> <span class="token string">&quot;inner&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>innerVar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// &quot;inner&quot;（当前作用域）</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// &quot;outer&quot;（外层函数作用域）</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// &quot;global&quot;（全局作用域）</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>就近原则</strong>：优先使用当前作用域的变量。</p><h3 id="常见问题与解决方案" tabindex="-1"><a class="header-anchor" href="#常见问题与解决方案"><span>常见问题与解决方案</span></a></h3><ol><li>变量污染 （全局作用域） <ul><li>问题：意外创建全局变量。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  leakedVar <span class="token operator">=</span> <span class="token string">&quot;泄露到全局&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 未用 var/let/const 声明 → 变为全局变量</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解决： 严格模式 (<code>use strict;</code>) 禁止未声明的变量赋值。</li></ul></li><li>闭包内存泄露 <ul><li>问题： 闭包长期引用外部变量，阻止GC（Garbage Collection，垃圾回收机制）</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">createHeavyClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> bigData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bigData<span class="token punctuation">;</span> <span class="token comment">// 闭包持有 bigData 的引用</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解决：使用后手动解除引用（如 <code>closure = null</code>）</li></ul></li><li>循环中的变量泄露（ <code>var</code> 陷阱） <ul><li>问题： <code>var</code> 在循环中泄露到外部作用域。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 3, 3, 3</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解决：改用 <code>let</code> 实现块级作用域。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 0, 1, 2</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h3><ol><li>优先使用 <code>const</code>：默认声明常量，减少意外修改。</li><li>必要时用 <code>let</code>：需要重新赋值时使用块级作用域。</li><li>避免使用 <code>var</code>：除非维护旧代码。</li><li>减少全局变量： 使用模块化 (ES6 Module) 封装作用域。</li><li>合理使用闭包： 及时解除不再需要的引用。</li></ol><blockquote><p><strong>重用变量还是新建它？</strong><br> 最后一点，对于一些程序员，倾向于重用现有的变量，而不是声明一个新的变量。 这个变量就像是被扔进了不同的盒子但是没有改变他的标签贴纸，谁知道里面是什么？我们往往需要花费时间仔细检查才能知道发生了什么。 这样节省了一点变量声明的时间，但却在调试代码的时候损失了数十倍的时间。 额外声明一个变量绝对是利大于弊的。 现代的 JavaScript 压缩器和浏览器都能很好的对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。</p></blockquote>`,36)]))}const i=s(p,[["render",l],["__file","03-bianliang.html.vue"]]),u=JSON.parse('{"path":"/series/JavaScript/01-JavaScriptjichuzhishi/03-bianliang.html","title":"变量","lang":"zh-CN","frontmatter":{"title":"变量","date":"2025-02-01 18:51"},"headers":[{"level":2,"title":"变量","slug":"变量-1","link":"#变量-1","children":[]},{"level":2,"title":"变量命名和保留字","slug":"变量命名和保留字","link":"#变量命名和保留字","children":[]},{"level":2,"title":"三种变量简介","slug":"三种变量简介","link":"#三种变量简介","children":[]},{"level":2,"title":"变量四个基本阶段","slug":"变量四个基本阶段","link":"#变量四个基本阶段","children":[]},{"level":2,"title":"预解析、变量提升和TDZ（暂时性死区）","slug":"预解析、变量提升和tdz-暂时性死区","link":"#预解析、变量提升和tdz-暂时性死区","children":[]},{"level":2,"title":"变量内存空间的分配","slug":"变量内存空间的分配","link":"#变量内存空间的分配","children":[]},{"level":2,"title":"变量作用域","slug":"变量作用域","link":"#变量作用域","children":[{"level":3,"title":"作用域类型","slug":"作用域类型","link":"#作用域类型","children":[]},{"level":3,"title":"作用域链 （Scope Chain）","slug":"作用域链-scope-chain","link":"#作用域链-scope-chain","children":[]},{"level":3,"title":"常见问题与解决方案","slug":"常见问题与解决方案","link":"#常见问题与解决方案","children":[]},{"level":3,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[]}]}],"git":{},"filePathRelative":"series/JavaScript/01-JavaScript基础知识/03-变量.md"}');export{i as comp,u as data};
